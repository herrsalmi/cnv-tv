tailla <- length(summary(res1))
nodata <- data.frame("M/Z"= numeric(0), "p.value"= numeric(0))
col <- colnames(matrix)
for(i in 1:tailla)
{
p.value <-summary(res1)[[i]][["Pr(>F)"]]
pvalue <- p.value[1]
nodata[i,2] <- pvalue
nodata[i,1] <- col[i]
}
res <- nodata[nodata$p.value<pval,]
tp <- length(intersect(li, res$M.Z))
fn <- 30 - tp
fp <- length(res$p.value) - tp
tn <- 300 - (fn+fp+tp)
TPR <- (tp)/(tp+fn)
FPR <- (fp)/(fp+tn)
list('TPR' = TPR, 'FPR' = FPR)
}
roc.val.anova(0.05)
x <- vector(mode = 'numeric')
y <- vector(mode = 'numeric')
x <- c(x, 0)
y <- c(y, 0)
for (i in seq(0.005, 1, by = 0.005)) {
var <- roc.val.anova(i)
x <- c(x, var$FPR)
y <- c(y, var$TPR)
}
install.packages("cn.mops")
library(BiocInstaller)
biocLite("cn.mops")
library(cn.mops)
bamFile <- list.files(~"")
bamFile <- list.files("~/", pattern = ".bam$")
bamFile
bamData <- getReadCountsFromBAM(bamFile)
bamData <- getReadCountsFromBAM(bamFile, mode = "paired")
res <- cn.mops(bamData)
BAMFiles <- list.files(system.file("extdata", package="cn.mops"),pattern=".bam$",full.names=TRUE)
bamDataRanges <- getReadCountsFromBAM(BAMFiles,sampleNames=paste("Sample",1:3),mode="unpaired")
res <- cn.mops(bamDataRanges)
res
(bamDataRanges)
biocLite()
library(cnv)
install.packages(cnv)
install.packages("cnv")
install.packages(pkgs="cnv-seq.tar.gz", repo=NULL)
install.packages("glmnet")
library(glmnet)
x=matrix(rnorm(100*20),100,20)
y=rnorm(100)
fit <- glmnet(x, y)
print(fit)
coef(fit1,s=0.01) # extract coefficients at a single value of lambda
predict(fit1,newx=x[1:10,],s=c(0.01,0.005)) # make predictions
coef(fit,s=0.01)
predict(fit,newx=x[1:10,],s=c(0.01,0.005))
plot(fit)
plot(x, y)
x
y
install.packages("lars")
library(lars)
data(diabetes)
data(diabetes)
par(mfrow=c(2,2))
attach(diabetes)
attach(diabetes)
par(mfrow=c(2,2))
attach(diabetes)
data(diabetes)
par(mfrow=c(2,2))
attach(diabetes)
View(diabetes)
object <- lars(x,y)
plot(object)
attach(diabetes)
plot(diabetes)
View(diabetes)
object
object$meanx
install.packages("genlasso")
library(genlasso)
set.seed(1)
n<- 100
i <- 1:n
y = (i > 20 & i < 30) + 5*(i > 50 & i < 70) + rnorm(n, sd=0.1)
y
out = fusedlasso1d(y)
plot(out, lambda = 1)
plot(out, lambda = 2)
plot(out, lambda = 10)
plot(out, lambda = 0.5)
plot(out, lambda = 1)
plot(out, lambda = 1)
out
out$lambda
out$fit
out$u
out$beta
View(out$beta)
y
rnorm(100, 30, 5)
y <- rnorm(100, 30, 5)
out = fusedlasso1d(y)
plot(out, lambda = 1)
plot(out, lambda = 5)
plot(out, lambda = 0.3)
View(out$beta)
out$bls
y
out$y
out$completepath
out$df
out$lambda
out$u
View(out$u)
out$lambda
install.packages("dtw")
install.packages("dtw")
install.packages("dtw")
log(2)
log2(2)
log2(1)
log2(1.5)
library(genlasso)
library(genlasso)
set.seed(0)
n = 50
beta0 = rep(sample(1:10,5),each=n/5)
y = beta0 + rnorm(n,sd=0.8)
a = fusedlasso1d(y)
plot(a)
cv = cv.trendfilter(a)
plotplogis())
plot(cv)
plot(a,lambda=cv$lambda.min,main="Minimal CV error")
plot(a,lambda=cv$lambda.1se,main="One standard error rule")
cv$lambda
plot(a,lambda=cv$lambda.1se,main="One standard error rule")
plot(a,lambda=cv$lambda.min,main="Minimal CV error")
plot(a,lambda=cv$lambda.1se,main="One standard error rule")
d <- data.frame("a" = c(1,2,0,3), "b" = c(12,15,16,17))
d
d[1]
d[1,]
d[which(d[,1] != 0),]
x <- c(1.30, 1.31, 1.11, 1.08, 1.09, 1.13, 1.65,
1.26, 1.26, 1.18)
mean(x)
var(x)
x <- c(7.5, 4.48, 8.60, 7.73, 5.28, 4.25, 6.99,
6.31, 9.15, 5.06)
y <- c(28.66, 20.37, 22.33, 26.35, 22.29, 21.74,
23.11, 23.13, 24.68, 21.89)
plot(x, y)
cor(x, y, method = "pearson")
cov(x, y, method = "pearson")
mean(1:10)
mean(7:20)
n1 <- c(9, 9, 5, 5, 5, 6, 16, 8, 8, 7)
n2 <- c(13, 11, 14, 13, 12, 11)
t.test(n1 ,n2)
var(n1)
var(n2)
t.test(n1 ,n2, var.equal = TRUE)
n1 <- c(9, 9, 5, 5, 5, 6, 16, 8, 8, 7)
n2 <- c(13, 11, 14, 13, 12, 11)
t.test(n1 ,n2, var.equal = T)
library(GenomicAlignments)
source("https://bioconductor.org/biocLite.R")
biocLite()
setwd("~/GitHub/cnv-tv")
library(GenomicAlignments)
library(genlasso)
source("gcCorrection.R")
Rcpp::sourceCpp('gc.content.cpp')
binSize<-100
windowSize <- 0.2e+6
prefix <- "test"
#' OS type
#'
#' Detects OS type to set null device used for messages redirection
#'
#' @return OS type
get_os <- function(){
sysinf <- Sys.info()
if (!is.null(sysinf)){
os <- sysinf['sysname']
if (os == 'Darwin')
os <- "osx"
} else { ## mystery machine
os <- .Platform$OS.type
if (grepl("^darwin", R.version$os))
os <- "osx"
if (grepl("linux-gnu", R.version$os))
os <- "linux"
if (grepl("mingw32", R.version$os))
os <- "windows"
}
tolower(os)
}
## Set null device
if (get_os() == "windows") {
NULL.DEV <- "NUL"
} else {
NULL.DEV <- "/dev/null"
}
#' Mean read depth over a sliding windows
#'
#' @param windowsize sliding window size
#' @param inputseq vector of read depth per base
#' @return list with positions, mean depth and sd
slidingwindowcoverage <- function(windowsize, inputseq) {
starts <- seq(1, length(inputseq)-windowsize, by=windowsize)
n <- length(starts)
chunkbps <- numeric(n)
chunkstats<- numeric(n)
for (i in 1:n) {
chunk <- inputseq[starts[i]:(starts[i]+windowsize-1)]
chunkmean <- mean(chunk)
chunkstdv <- sd(chunk)
chunkbps[i] <- chunkmean
chunkstats[i] <- chunkstdv
}
return (list(starts,chunkbps,chunkstats))
}
#' Finds segments with uniform intensities
#'
#' @param x vector of intensities
#' @return list of (starts,ends) of segments
findSegment <- function(x) {
starts <- 1
ends <- c()
for (i in seq(2, length(x))) {
if (round(x[i-1], 6) == round(x[i], 6)) {
next()
} else {
starts <- c(starts, i)
ends <- c(ends, i-1)
}
}
ends <- c(ends, length(x))
return(cbind(starts, ends))
}
#' Groups intensities with sequential indexes
#'
#' @param x indexes from list of dup/del
#' @return list of (starts,ends) of segments
group <- function(x){
starts <- x[1]
ends <- c()
for (i in seq(2, length(x))) {
if (x[i-1] + 1 == x[i]) {
next()
} else {
starts <- c(starts, x[i])
ends <- c(ends, x[i-1])
}
}
ends <- c(ends, x[length(x)])
return(cbind(starts, ends))
}
#' Computes coverage for each base from a BAM file
#'
#' @param file BAM file
#' @return coverage values for each base
extractCoverageFromBAM <- function(file) {
param <- ScanBamParam(flag=scanBamFlag(isUnmappedQuery=FALSE,
isDuplicate=FALSE),
what=c("rname", "pos", "cigar"))
bam <- scanBam(file, param=param)[[1]]
## Note that unmapped reads and reads that are PCR/optical duplicates
## have already been filtered out by using the ScanBamParam object above.
irl <- extractAlignmentRangesOnReference(bam$cigar, pos=bam$pos,
f=bam$rname)
irl <- irl[elementNROWS(irl) != 0] # drop empty elements
coverage(irl)
}
#' Mean coverage as data.frame
#'
#' Calls slidingwindowcoverage and returns a formated data.farme
#'
#' @param cvg coverage values for each base
#' @return data.frame of mean coverage
computeMeanCoverage <- function(cvg){
myvector_all <- as.vector(cvg)
windowAll <- slidingwindowcoverage(binSize, myvector_all)
df <- data.frame(windowAll[[1]],windowAll[[2]],windowAll[[3]])
colnames(df) <- c("x","mean","sd")
return(df)
}
#' Detects CNVs in window
#'
#' Detects CNVs in window defined by (start,end) using LASSO solver
#' and sets thresholds for CNV calling by using a lognormal distribution
#'
#' @param data mean coverage
#' @param start start position of the window
#' @param end end position of the window
#' @param chrom.name chromosome name
#' @return data.frame of dup/del positions in window
get.cnv <- function(data, start, end, chrom.name){
y <- data[data$x >= start & data$x <= end,]
out <- fusedlasso1d(y$mean, y$x)
sink(file = NULL.DEV)
cv <- cv.trendfilter(out)
sink()
x <- coef(out, lambda = cv$lambda.1se)
x <- x$beta
seg <- findSegment(x)
names(seg) <- NULL
ampl <- c()
for (i in 1:length(seg[,1])) {
ampl <- c(ampl, sum(y$mean[seg[i,1]:seg[i,2]]) / (seg[i,2] - seg[i,1] + 1) )
}
seg.length <- (seg[,2] - seg[,1] + 1)
x.t <- rep(ampl, seg[,2] - seg[,1] + 1)
names(x.t) <- NULL
svg(paste0("Plots_", prefix,"/", chrom.name, "_", start, "_", end, ".svg"),width=14,height=7)
plot(out, lambda = cv$lambda.1se, pch = ".", cex = 2)
lines(y$x, x.t, col = "red")
#upper.q <- quantile(x.t, prob = 0.975)
#lower.q <- quantile(x.t, prob = 0.025)
#f <- (y$mean[y$mean >= lower.q & y$mean <= upper.q])
f <- y$mean[y$mean > 0]
if(length(f) == 0) {
dev.off()
return(NULL)
}
params <- fitdistr(f, "lognormal")
upper.thr <- qlnorm(0.975, params$estimate['meanlog'], params$estimate['sdlog'])
lower.thr <- qlnorm(0.025, params$estimate['meanlog'], params$estimate['sdlog'])
abline(a = lower.thr, b = 0, col = "green")
abline(a = upper.thr, b = 0, col = "green")
dev.off()
type <- vector(mode = "character")
type[x.t >= upper.thr] <- "dup"
type[x.t <= lower.thr] <- "del"
x.t[x.t < upper.thr & x.t > lower.thr] <- 0
return(data.frame(intensity = x.t, pos = y$x, type = type))
}
#' Processes a chromosome for CNVs using sliding windows of pre-defined size
#'
#' @param chrom coverage over chromosome
#' @param chrom.name chromosome name
extract.cnv <- function(chrom, chrom.name) {
starts <- seq(1, length(chrom)-windowSize, by=windowSize)
starts <- c(starts, length(chrom))
n <- length(starts) - 1
data <- computeMeanCoverage(chrom)
# GC correction
data$mean <- gc.norm(ref, data$mean)
print(paste0("Processing chromosome ", chrom.name))
pb <- txtProgressBar(min = 0, max = n, style = 3)
for (i in 1:n) {
#print(paste0("Processing ", chrom.name, ":", starts[i], "-",starts[i+1]))
setTxtProgressBar(pb, i)
cnv.list <- get.cnv(data, starts[i], starts[i+1], chrom.name)
if(is.null(cnv.list)) {
next()
}
i <- which(!is.na(cnv.list$type))
g <- group(i)
intensities <- vector(mode = "numeric")
for (index in 1:(length(g)/2)) {
intensities <- c(intensities, max(cnv.list$intensity[g[index,1]:g[index,2]]))
}
cnv <- data.frame("Chrom" = chrom.name, "Start" = cnv.list$pos[g[,1]], "End" = cnv.list$pos[g[,2]],
"Type" = cnv.list$type[g[,1]], "Length" = (g[,2] - g[,1]) * 100, "Intensity" = intensities)
## drop element with length=0
cnv <- cnv[which(cnv[,5] != 0),]
write.table(cnv, file = paste0(prefix,"_CNV_TV_result.txt"), append = TRUE, sep = "\t",
row.names = FALSE, col.names = FALSE)
}
close(pb)
}
file <- "Data/out.sorted.bam"
ref <- readDNAStringSet("Data/NC_008253.fa")
cvg <- extractCoverageFromBAM(file)
write("Chromosome\tStart\tEnd\tType\tLength\tIntensity", file = paste0(prefix,"_CNV_TV_result.txt"),
append = FALSE)
chrom.names <- names(cvg@listData)
chrom.index <- 1
for (i in cvg@listData) {
## GC bias correction goes here
extract.cnv(i, chrom.names[chrom.index])
chrom.index <- chrom.index + 1
}
file <- "Data/aln.sorted.bam"
ref <- readDNAStringSet("Data/NC_008253.fa")
cvg <- extractCoverageFromBAM(file)
file <- "Data/aln.bam"
ref <- readDNAStringSet("Data/NC_008253.fa")
cvg <- extractCoverageFromBAM(file)
write("Chromosome\tStart\tEnd\tType\tLength\tIntensity", file = paste0(prefix,"_CNV_TV_result.txt"),
append = FALSE)
chrom.names <- names(cvg@listData)
chrom.index <- 1
for (i in cvg@listData) {
extract.cnv(i, chrom.names[chrom.index])
chrom.index <- chrom.index + 1
}
get.cnv <- function(data, start, end, chrom.name){
y <- data[data$x >= start & data$x <= end,]
out <- fusedlasso1d(y$mean, y$x)
sink(file = NULL.DEV)
cv <- cv.trendfilter(out)
sink()
x <- coef(out, lambda = cv$lambda.1se)
x <- x$beta
seg <- findSegment(x)
names(seg) <- NULL
ampl <- c()
for (i in 1:length(seg[,1])) {
ampl <- c(ampl, sum(y$mean[seg[i,1]:seg[i,2]]) / (seg[i,2] - seg[i,1] + 1) )
}
seg.length <- (seg[,2] - seg[,1] + 1)
x.t <- rep(ampl, seg[,2] - seg[,1] + 1)
names(x.t) <- NULL
svg(paste0("Plots_", prefix,"/", chrom.name, "_", start, "_", end, ".svg"),width=14,height=7)
plot(out, lambda = cv$lambda.1se, pch = ".", cex = 2)
lines(y$x, x.t, col = "red")
#upper.q <- quantile(x.t, prob = 0.975)
#lower.q <- quantile(x.t, prob = 0.025)
#f <- (y$mean[y$mean >= lower.q & y$mean <= upper.q])
f <- y$mean[y$mean > 0]
if(length(f) == 0) {
dev.off()
return(NULL)
}
params <- fitdistr(f, "lognormal")
upper.thr <- qlnorm(0.975, params$estimate['meanlog'], params$estimate['sdlog'])
lower.thr <- qlnorm(0.012, params$estimate['meanlog'], params$estimate['sdlog'])
abline(a = lower.thr, b = 0, col = "green")
abline(a = upper.thr, b = 0, col = "green")
dev.off()
type <- vector(mode = "character")
type[x.t >= upper.thr] <- "dup"
type[x.t <= lower.thr] <- "del"
x.t[x.t < upper.thr & x.t > lower.thr] <- 0
return(data.frame(intensity = x.t, pos = y$x, type = type))
}
cvg <- extractCoverageFromBAM(file)
write("Chromosome\tStart\tEnd\tType\tLength\tIntensity", file = paste0(prefix,"_CNV_TV_result.txt"),
append = FALSE)
chrom.names <- names(cvg@listData)
chrom.index <- 1
for (i in cvg@listData) {
extract.cnv(i, chrom.names[chrom.index])
chrom.index <- chrom.index + 1
}
warnings()
get.cnv <- function(data, start, end, chrom.name){
# Skip 500Bp from the begening and end of the chromosom
if (start < 500)
start <- 501
if (end > tail(data$x, n=1)-500)
end <- tail(data$x, n=1)-500
y <- data[data$x >= start & data$x <= end,]
out <- fusedlasso1d(y$mean, y$x)
sink(file = NULL.DEV)
cv <- cv.trendfilter(out)
sink()
x <- coef(out, lambda = cv$lambda.1se)
x <- x$beta
seg <- findSegment(x)
names(seg) <- NULL
ampl <- c()
for (i in 1:length(seg[,1])) {
ampl <- c(ampl, sum(y$mean[seg[i,1]:seg[i,2]]) / (seg[i,2] - seg[i,1] + 1) )
}
seg.length <- (seg[,2] - seg[,1] + 1)
x.t <- rep(ampl, seg[,2] - seg[,1] + 1)
names(x.t) <- NULL
svg(paste0("Plots_", prefix,"/", chrom.name, "_", start, "_", end, ".svg"),width=14,height=7)
plot(out, lambda = cv$lambda.1se, pch = ".", cex = 2)
lines(y$x, x.t, col = "red")
#upper.q <- quantile(x.t, prob = 0.975)
#lower.q <- quantile(x.t, prob = 0.025)
#f <- (y$mean[y$mean >= lower.q & y$mean <= upper.q])
f <- y$mean[y$mean > 0]
if(length(f) == 0) {
dev.off()
return(NULL)
}
params <- fitdistr(f, "lognormal")
upper.thr <- qlnorm(0.975, params$estimate['meanlog'], params$estimate['sdlog'])
lower.thr <- qlnorm(0.012, params$estimate['meanlog'], params$estimate['sdlog'])
abline(a = lower.thr, b = 0, col = "green")
abline(a = upper.thr, b = 0, col = "green")
dev.off()
type <- vector(mode = "character")
type[x.t >= upper.thr] <- "dup"
type[x.t <= lower.thr] <- "del"
x.t[x.t < upper.thr & x.t > lower.thr] <- 0
return(data.frame(intensity = x.t, pos = y$x, type = type))
}
cvg <- extractCoverageFromBAM(file)
write("Chromosome\tStart\tEnd\tType\tLength\tIntensity", file = paste0(prefix,"_CNV_TV_result.txt"),
append = FALSE)
chrom.names <- names(cvg@listData)
chrom.index <- 1
for (i in cvg@listData) {
extract.cnv(i, chrom.names[chrom.index])
chrom.index <- chrom.index + 1
}
d <- read.table("test_CNV_TV_result.txt", header = T, sep = "\t")
View(d)
d$Type
