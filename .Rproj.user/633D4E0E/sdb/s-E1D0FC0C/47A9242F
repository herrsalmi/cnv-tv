{
    "collab_server" : "",
    "contents" : "#require(ggplot2)\n#library(plotly)\nlibrary(GenomicAlignments)\nlibrary(genlasso)\nsource(\"gcCorrection.R\")\nRcpp::sourceCpp('gc.content.cpp')\n\nbinSize<-100\nwindowSize <- 0.2e+6\nprefix <- \"sim3\"\nupper.thr <- numeric()\nlower.thr <- numeric()\nref <- DNAStringSet()\n\n#' OS type\n#' \n#' Detects OS type to set null device used for messages redirection\n#' \n#' @return OS type\nget_os <- function(){\n  sysinf <- Sys.info()\n  if (!is.null(sysinf)){\n    os <- sysinf['sysname']\n    if (os == 'Darwin')\n      os <- \"osx\"\n  } else { ## mystery machine\n    os <- .Platform$OS.type\n    if (grepl(\"^darwin\", R.version$os))\n      os <- \"osx\"\n    if (grepl(\"linux-gnu\", R.version$os))\n      os <- \"linux\"\n    if (grepl(\"mingw32\", R.version$os))\n      os <- \"windows\"\n  }\n  tolower(os)\n}\n\n## Set null device\nif (get_os() == \"windows\") {\n  NULL.DEV <- \"NUL\"\n} else {\n  NULL.DEV <- \"/dev/null\"\n}\n\n#' Mean read depth over a sliding windows\n#' \n#' @param windowsize sliding window size\n#' @param inputseq vector of read depth per base\n#' @return list with positions, mean depth and sd\nslidingwindowcoverage <- function(windowsize, inputseq) {\n  starts <- seq(1, length(inputseq)-windowsize, by=windowsize)\n  n <- length(starts)\n  chunkbps <- numeric(n)\n  chunkstats<- numeric(n)\n  for (i in 1:n) {\n    chunk <- inputseq[starts[i]:(starts[i]+windowsize-1)] \n    chunkmean <- mean(chunk)\n    chunkstdv <- sd(chunk)\n    chunkbps[i] <- chunkmean\n    chunkstats[i] <- chunkstdv\n  }\n  return (list(starts,chunkbps,chunkstats))\n}\n\n#' Finds segments with uniform intensities\n#' \n#' @param x vector of intensities\n#' @return list of (starts,ends) of segments\nfindSegment <- function(x) {\n  starts <- 1\n  ends <- c()\n  for (i in seq(2, length(x))) {\n    if (round(x[i-1], 6) == round(x[i], 6)) {\n      next()\n    } else {\n      starts <- c(starts, i)\n      ends <- c(ends, i-1)\n    }\n  }\n  ends <- c(ends, length(x))\n  return(cbind(starts, ends))\n}\n\n#' Groups intensities with sequential indexes\n#' \n#' @param x indexes from list of dup/del\n#' @return list of (starts,ends) of segments\ngroup <- function(x){\n  starts <- x[1]\n  ends <- c()\n  for (i in seq(2, length(x))) {\n    if (x[i-1] + 1 == x[i]) {\n      next()\n    } else {\n      starts <- c(starts, x[i])\n      ends <- c(ends, x[i-1])\n    }\n  }\n  ends <- c(ends, x[length(x)])\n  return(cbind(starts, ends))\n}\n\n#' Computes coverage for each base from a BAM file\n#' \n#' @param file BAM file\n#' @return coverage values for each base\nextractCoverageFromBAM <- function(file) {\n  param <- ScanBamParam(flag=scanBamFlag(isUnmappedQuery=FALSE,\n                                         isDuplicate=FALSE),\n                        what=c(\"rname\", \"pos\", \"cigar\"))\n  bam <- scanBam(file, param=param)[[1]]\n  ## Note that unmapped reads and reads that are PCR/optical duplicates\n  ## have already been filtered out by using the ScanBamParam object above.\n  irl <- extractAlignmentRangesOnReference(bam$cigar, pos=bam$pos,\n                                           f=bam$rname)\n  irl <- irl[elementNROWS(irl) != 0] # drop empty elements\n  coverage(irl)\n}\n\n#' Mean coverage as data.frame\n#' \n#' Calls slidingwindowcoverage and returns a formated data.farme\n#' \n#' @param cvg coverage values for each base\n#' @return data.frame of mean coverage\ncomputeMeanCoverage <- function(cvg){\n  myvector_all <- as.vector(cvg)\n  windowAll <- slidingwindowcoverage(binSize, myvector_all)\n  df <- data.frame(windowAll[[1]],windowAll[[2]],windowAll[[3]])\n  colnames(df) <- c(\"x\",\"mean\",\"sd\")\n  return(df)\n}\n\n#' Detects CNVs in window\n#' \n#' Detects CNVs in window defined by (start,end) using LASSO solver\n#' and sets thresholds for CNV calling by using a lognormal distribution\n#' \n#' @param data mean coverage\n#' @param start start position of the window\n#' @param end end position of the window\n#' @param chrom.name chromosome name\n#' @return data.frame of dup/del positions in window\nget.cnv <- function(data, start, end, chrom.name){\n  # Skip 500Bp from the begening and end of the chromosom\n  if (start < 500)\n    start <- 501\n  if (end > tail(data$x, n=1)-500)\n    end <- tail(data$x, n=1)-500\n  y <- data[data$x >= start & data$x <= end,]\n  out <- fusedlasso1d(y$mean, y$x)\n  sink(file = NULL.DEV)\n  cv <- cv.trendfilter(out)\n  sink()\n  x <- coef(out, lambda = cv$lambda.1se)\n  x <- x$beta\n  seg <- findSegment(x)\n  names(seg) <- NULL\n  ampl <- c()\n  for (i in 1:length(seg[,1])) {\n    ampl <- c(ampl, sum(y$mean[seg[i,1]:seg[i,2]]) / (seg[i,2] - seg[i,1] + 1) )\n  }\n  seg.length <- (seg[,2] - seg[,1] + 1)\n  x.t <- rep(ampl, seg[,2] - seg[,1] + 1)\n  names(x.t) <- NULL\n  svg(paste0(\"Plots_\", prefix,\"/\", chrom.name, \"_\", start, \"_\", end, \".svg\"),width=14,height=7)\n  plot(out, lambda = cv$lambda.1se, pch = \".\", cex = 2, color = 'blue')\n  lines(y$x, x.t, col = \"red\")\n  abline(a = lower.thr, b = 0, col = \"green\")\n  abline(a = upper.thr, b = 0, col = \"green\")\n  dev.off()\n  type <- vector(mode = \"character\")\n  type[x.t >= upper.thr] <- \"dup\"\n  type[x.t <= lower.thr] <- \"del\"\n  x.t[x.t < upper.thr & x.t > lower.thr] <- 0\n  return(data.frame(intensity = x.t, pos = y$x, type = type))\n}\n\n#' Processes a chromosome for CNVs using sliding windows of pre-defined size\n#' \n#' @param chrom coverage over chromosome\n#' @param chrom.name chromosome name\nextract.cnv <- function(chrom, chrom.name) {\n  starts <- seq(1, length(chrom)-windowSize, by=windowSize)\n  starts <- c(starts, length(chrom))\n  n <- length(starts) - 1\n  data <- computeMeanCoverage(chrom)\n  # GC correction\n  data$mean <- gc.norm(ref, data$mean)\n  # compute thresholds\n  f <- data$mean[data$mean > 0]\n  params <- fitdistr(f, \"lognormal\")\n  upper.thr <<- qlnorm(0.975, params$estimate['meanlog'], params$estimate['sdlog'])\n  lower.thr <<- qlnorm(0.012, params$estimate['meanlog'], params$estimate['sdlog'])\n  \n  print(paste0(\"Processing chromosome \", chrom.name))\n  # fixe the pb: min=1\n  pb <- txtProgressBar(min = 1, max = n, style = 3)\n  for (i in 1:n) {\n    #print(paste0(\"Processing \", chrom.name, \":\", starts[i], \"-\",starts[i+1]))\n    setTxtProgressBar(pb, i)\n    cnv.list <- get.cnv(data, starts[i], starts[i+1], chrom.name)\n    if(is.null(cnv.list) || length(cnv.list) == 0) {\n      next()\n    }\n    i <- which(!is.na(cnv.list$type))\n    if (length(i) < 2) {\n      next()\n    }\n    g <- group(i)\n    intensities <- vector(mode = \"numeric\")\n    for (index in 1:(length(g)/2)) {\n      intensities <- c(intensities, max(cnv.list$intensity[g[index,1]:g[index,2]]))\n    }\n    cnv <- data.frame(\"Chrom\" = chrom.name, \"Start\" = cnv.list$pos[g[,1]], \"End\" = cnv.list$pos[g[,2]], \n                      \"Type\" = cnv.list$type[g[,1]], \"Length\" = (g[,2] - g[,1]) * 100, \"Intensity\" = intensities)\n    ## drop element with length=0\n    cnv <- cnv[which(cnv[,5] != 0),]\n    write.table(cnv, file = paste0(prefix,\"_CNV_TV_result.tmp\"), append = TRUE, sep = \"\\t\", \n                row.names = FALSE, col.names = FALSE)\n    \n  }\n  close(pb)\n}\n\ncnv.filter <- function(){\n  d <- read.table(paste0(prefix,\"_CNV_TV_result.tmp\"), header = T, sep = \"\\t\")\n  del <- d[d$Type==\"del\",]$Intensity\n  dup <- d[d$Type==\"dup\",]$Intensity\n  ## del threshold\n  if (length(del) > 1) {\n    k <- suppressWarnings(kmeans(del,2))\n    grp <- which(k$centers == max(k$centers))\n    del <- del[which(k$cluster == grp)]\n  }\n  params = suppressWarnings(fitdistr(del, \"poisson\"))\n  thr.del <- params$estimate + qnorm(0.95)*params$sd/sqrt(length(del))\n  \n  ## dup threshold\n  if (length(dup) > 1) {\n    k <- suppressWarnings(kmeans(dup,2))\n    grp <- which(k$centers == min(k$centers))\n    dup <- dup[which(k$cluster == grp)]\n  }\n  params = suppressWarnings(fitdistr(dup, \"poisson\"))\n  thr.dup <- params$estimate - qnorm(0.975)*params$sd/sqrt(length(dup))\n  \n  d <- d[which((d$Type==\"del\" & d$Intensity < thr.del) | (d$Type==\"del\" & d$Length >= 800) | (d$Type==\"dup\" & d$Intensity > thr.dup) | (d$Type==\"dup\" & d$Length >= 800)),]\n  \n  write.table(d, file = paste0(prefix,\"_CNV_TV_result.txt\"), append = FALSE, sep = \"\\t\", \n              row.names = FALSE, col.names = TRUE)\n  #file.remove(paste0(prefix,\"_CNV_TV_result.tmp\"))\n}\n\nrun.cnv.tv <- function(file, fasta){\n  file <- \"Data/NA19375.chrom20.ILLUMINA.bwa.LWK.low_coverage.20120522.bam\"\n  fasta <- \"Data/Homo_sapiens.GRCh38.dna.chromosome.20.fa\"\n  \n  file <- \"Data/sim3.bam\"\n  fasta <- \"Data/NC_008253.fa\"\n  \n  ref <<- readDNAStringSet(fasta)\n  \n  cvg <- extractCoverageFromBAM(file)\n  \n  # Create directory for graphics output\n  dir.create(paste0(\"Plots_\", prefix), showWarnings = TRUE, recursive = FALSE, mode = \"0777\")\n  \n  write(\"Chromosome\\tStart\\tEnd\\tType\\tLength\\tIntensity\", file = paste0(prefix,\"_CNV_TV_result.tmp\"),\n        append = FALSE)\n  chrom.names <- names(cvg@listData)\n  chrom.index <- 1\n  for (i in cvg@listData) {\n    #meanCvg <<- mean(i)\n    extract.cnv(i, chrom.names[chrom.index])\n    chrom.index <- chrom.index + 1\n  }\n  cnv.filter()\n  \n}\n\n\n###########################################################################\nd <- data.frame(dp=as.numeric(cvg$`20`[60000:2000000]))\n\nggplot(d, aes(d$dp)) + \n  geom_histogram(aes(y=..density..),binwidth = 1) +\n  scale_y_continuous('frequency') +\n  geom_vline(xintercept = 9.7, col = \"green\") \n\nhist(d$dp, prob = T, xlab = \"Read Depth\", main = \"Histogram of Read Depth\")\nabline(v = 9.7, col = \"green\")\nm<-mean(d)\nstd<-sqrt(var(d))\ncurve(dnorm(x, mean=m, sd=std), add=TRUE, col = \"blue\")\nd <- remove_outliers(d)\nd <- d[!is.na(d)]\nparams <- fitdistr(d[d != 0], \"lognormal\")\ncurve(dlnorm(x, meanlog = params$estimate['meanlog'], sdlog = params$estimate['sdlog'], log = FALSE), add=TRUE, col = \"red\")\n\nremove_outliers <- function(x, na.rm = TRUE, ...) {\n  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)\n  H <- 1.5 * IQR(x, na.rm = na.rm)\n  y <- x\n  y[x < (qnt[1] - H)] <- NA\n  y[x > (qnt[2] + H)] <- NA\n  y\n}\n\n",
    "created" : 1477303023115.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3837450680",
    "id" : "47A9242F",
    "lastKnownWriteTime" : 1475181473,
    "last_content_update" : 1475181473,
    "path" : "~/GitHub/cnv-tv/cnv_tv.R",
    "project_path" : "cnv_tv.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}